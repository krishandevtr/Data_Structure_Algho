# Time Complexity Overview

This section outlines the time complexities of common algorithms, listed from **lowest to highest**:

## Time Complexities (from Low to High)

1. **O(1) - Constant Time**:
   - The operation takes the same amount of time regardless of the input size.
   - Example: Accessing an element in an array by index.

2. **O(log n) - Logarithmic Time**:
   - Time grows logarithmically as the input size increases.
   - Example: Binary search.

3. **O(n) - Linear Time**:
   - Time grows linearly with the size of the input.
   - Example: Linear search, iterating through an array.
   
4. **O(n log n) - Log-Linear Time**:
   - Time grows slightly faster than linear time, but much slower than quadratic.
   - Example: Merge Sort, Quick Sort, Heap Sort.

5. **O(n²) - Quadratic Time**:
   - Time grows quadratically with the input size, i.e., the time is proportional to the square of the input size.
   - Example: Bubble Sort, Selection Sort, Insertion Sort.

6. **O(n³) - Cubic Time**:
   - Time grows cubicly with the input size.
   - Example: Some brute-force algorithms for matrix multiplication.

7. **O(2^n) - Exponential Time**:
   - Time doubles with each additional input element.
   - Example: Solving problems like the traveling salesman problem (brute-force approach).

8. **O(n!) - Factorial Time**:
   - Time grows factorially with the input size.
   - Example: Brute-force algorithms for permutations (e.g., solving the traveling salesman problem through all possible routes).

## Summary of Time Complexities (Low to High)

1. **O(1)** (Constant)
2. **O(log n)** (Logarithmic)
3. **O(n)** (Linear)
4. **O(n log n)** (Log-Linear)
5. **O(n²)** (Quadratic)
6. **O(n³)** (Cubic)
7. **O(2^n)** (Exponential)
8. **O(n!)** (Factorial)
